## Introduction



### Information Leakage

Comments and metadata review should be done in order to determine if any information is being leaked.

References:[WSTG-INFO-05](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/05-Review_Webpage_Comments_and_Metadata_for_Information_Leakage.html)

### Fingerprinting 

Identify the web application, web application framework, technology and version to determine known vulnerabilities and the appropriate exploits to use during testing.
Methods to indentify web application are:
- HTTP Headers
- Cookies: A relatively reliable way to identify a web application is by the application-specific cookies.
- HTML Source Code: For instance **HTML comments** that directly lead to application disclosure.
- Specific Files and Folders: Every application has its own specific **file and folder structure** on the server.

References: 
- [WSTG-INFO-08](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework.html)
- [WSTG-INFO-09](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/09-Fingerprint_Web_Application.html)

#### whatweb

[WhatWeb](https://github.com/urbanadventurer/WhatWeb) identifies websites.<br>
Its goal is to answer the question, “What is that Website?”. WhatWeb recognises web technologies including content management systems (CMS), blogging platforms, statistic/analytics packages, JavaScript libraries, web servers, and embedded devices.<br>
WhatWeb has over 1700 plugins, each to recognise something different. WhatWeb also identifies version numbers, email addresses, account IDs, web framework modules, SQL errors, and more

```bash
./whatweb victim.com # Scan victim.com
./whatweb -l # List the plugins supported
```

whatweb has different aggression levels (**-a**) which are:
- Stealthy (1): Makes one HTTP request per target. Also follows redirects.
- Aggressive (3): If a level 1 plugin is matched, additional requests will be made.
- Heavy (4): Makes a lot of HTTP requests per target. Aggressive tests from all plugins are used for all URLs.

#### Wappalyser

[Wappalyzer](https://www.wappalyzer.com/) is a browser extension, that can be added to ZAP, which find out the technology stack of any website.


#### BlindElephant

The [BlindElephant]() Web Application Fingerprinter attempts to discover the version of a (known) web application by comparing static files at known locations against precomputed hashes for versions of those files in all all available releases. The technique is fast, low-bandwidth, non-invasive, generic, and highly automatable.

BlindElephant.py -l

*Note that this tool is not maintain since multiple years*

#### Wordpress

[wpscan](https://github.com/wpscanteam/wpscan) is a free, for non-commercial use, black box WordPress security scanner written for security professionals and blog maintainers to test the security of their WordPress websites.
Here are some of the checks:
- The version of WordPress installed and any associated vulnerabilities
- What plugins and themes are installed and any associated vulnerabilities
- Username enumeration
- Backed up and publicly accessible wp-config.php files

When enumerating the WordPress version, installed plugins or installed themes, you can use three different "modes", which are:

- passive
- aggressive
- mixed

```bash
wpscan --url example.com -e vp,vt --random-user-agent --plugins-detection mixed --api-token # For all plugins and themes with known vulnerabilities using random User-Agent
wpscan --url example.com -e ap,at --random-user-agent --plugins-detection mixed # all plugins (ap) and all themes (at)
```

### Spidering/Crawling

Spidering is the technique og following all link **available** on a webste and download each content available.

By spidering, we will gather the potential attack surface in order to identify likely areas of weakness.
We will also understanding the structure of the application is paramount.

*Note that automated scans could fail because the site is complex and has issues with multiple requests*

- Requests:
  - Identify where GETs are used and where POSTs are used 
  - Identify all parameters used in GET and POST requests
  - Within the POST request, check hidden parameters (Through a proxy like Burp or ZAP)
- Responses:
  - Identify where new cookies are set (Set-Cookie header), modified, or added to.
  - Identify where there are any redirects 3xx, 400, 403 and 500 status cods

References: 
- [WSTG-INFO-06](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/06-Identify_Application_Entry_Points.html)
- [WSTG-INFO-07](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/07-Map_Execution_Paths_Through_Application.html)

##### Wget

You can use [wget](https://www.gnu.org/software/wget/manual/wget.html) to perform automated spidering
```bash
wget -r HTTP://VICTIM.COM -l 10 -e robots:off
```
- **-r**: Turn on recursive retrieving.
- **-l**: Specify recursion maximum depth level depth
- **--convert-links**: After the download is complete, convert the links in the document to make them suitable for local viewing.
- **--page-requisites**: This option causes Wget to download all the files that are necessary to properly display a given HTML page.

For more option please refer to this [link](https://www.gnu.org/software/wget/manual/wget.html#Recursive-Retrieval-Options)

*Note that wget will adheres to the robots.txt rules except if you specify -e robots=off*

##### ZAP

The OWASP ZAP Proxy "Spider" module allows you to automatically discover new resources (URLs) on a particular Site. It begins with a list of URLs to visit, called the seeds, which depends on how the Spider is started.

> / / / Todo Technology detection

"Forced browse" mode:
In Forced browse, you can perform HTTP Bruteforce using a dictionny list to find 
*Options* -> *Forced Browse*

##### FOCA Pro

[FOCA](https://github.com/ElevenPaths/FOCA) is an excellent website reconnaissance tool with lots of interesting features and capabilities.

FOCA allows you to spiders a website and extra data such as email addresses, names from the result.

### Nikto

Nikto is a tool that can be used to detect vulnerabilities based on default content within a website.
Some of the test within his databases are the result of botnet request towards sandbox environments.

It will examine a web server to find potential problems and security vulnerabilities, including:

- Server and software misconfigurations
- Default files and programs
- Insecure files and programs
- Outdated servers and programs

```bash
nikto -h host
```

Note that Nikto is very intrusive

Nitko can be used to perform [WSTG-CONF-01](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/01-Test_Network_Infrastructure_Configuration.html), [WSTG-CONF-02](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/02-Test_Application_Platform_Configuration.html), [WSTG-CONF-03](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/03-Test_File_Extensions_Handling_for_Sensitive_Information.html)
*Note that it is also done using Nmap in [Network101.md](../Network101.md)

##### Unreferenced Files, Interfaces and Folders

While most of the files within a web server are directly handled by the server itself, it isn’t uncommon to find unreferenced or forgotten files that can be used to obtain important information about the infrastructure or the credentials.

Also, administrator interfaces may be present in the application or on the application server.

```bash
gobuster dir -u https://target/ -b 403,404 --timeout 30s -t 3 -w /usr/share/seclists/Discovery/Web-Content/raft-large-files.txt # Enumerate files within the given directory
gobuster dir -u https://target/ -b 403,404 --timeout 30s -t 3 --discover-backup # Enumerate potential backup files within the given directory
gobuster dir -u https://target/ -b 403,404 --timeout 30s -t 3 -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories-lowercase.txt
gobuster dns -d *domainname* -t 8 -r 8.8.8.8 -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt # Enumerate subdomains within the given domain names
```

-b 403,404: While not showing 403,404 pages

Note that within Apache HTTP Server, on systems with multiple users, each user can be permitted to have a web site in their home directory using the UserDir directive. Visitors to a URL http://example.com/~**username**/ will get content out of the home directory of the user "username", out of the subdirectory specified by the UserDir directive.

References:
- [WSTG-CONF-05](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/05-Enumerate_Infrastructure_and_Application_Admin_Interfaces.html)

*If you don't know, now you know : [HTTP Status Codes](https://docs.microsoft.com/en-us/windows/win32/services/service-user-accounts)*

- **1xx**: Informational Codes
- **2xx**: Client Request Successfull
- **3xx**: Request Redirected
- **4xx**: Client Request Incomplete
  - **403** - Forbidden: Access to the requested resource is forbidden
  - **404** - Not Found: The requested document does not exist on the server
- **5xx**: Server Errors

### SSL

#### Heartbleed (CVE-2014-0160)

Heartbleed is a security bug in the OpenSSL cryptography library, which is a widely used implementation of the Transport Layer Security (TLS) protocol.

The vulnerability is classified as a buffer over-read, a situation where more data can be read than should be allowed.

```bash
nmap --script=ssl-heartbleed -p 443 # Test to see if it's vulnerable
python heartbleed-poc.py -n 200 -f dump.bin victim.com # Dump memory scan, will make 200 requests and put the output in the binary file dump.bin
```

### HTTP

##### WAF

> / / / To Do

###### Detection

[WhatWaf](https://github.com/Ekultek/WhatWaf) is an advanced firewall detection tool who's goal is to give you the idea of "There's a WAF?". 

```bash
./whatwaf -u URL --burp FILE-PATH --pa USER-AGENT
```

[wafw00f](https://github.com/EnableSecurity/wafw00f) is a security tool to perform fingerprinting on web applications and detect any web application firewall in use.
How it works:
- Step 1: Sends a *normal* HTTP request and analyses the response.
  &rarr; This identifies a number of WAF solutions.
- Step 2: If the WAF is not detected, it sends a number of *potentially malicious* HTTP requests.
  &rarr; Using simple logic, it may deduce which WAF it is.
- Step 3: 

```bash
wafw00f https://VICTIM.COM --findall # Find all WAFs which match the signatures, do not stop testing on the first one
```

###### Avoidance

> / / / To Finish

If you need to do a RCE within linux, you can replace spaces by **${IFS}**

Resources:
- NAXSI: 
  - https://www.synacktiv.com/en/publications/bypassing-naxsi-filtering-engine.html


##### HTTP Methods

HTTP offers a number of methods that can be used to perform actions on the web server. Many of theses methods are designed to aid developers in deploying and testing HTTP applications.

References: [WSTG-CONF-06](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/06-Test_HTTP_Methods)

###### Testing for HTTP PUT Method

> / / / To Finish

The HTTP PUT request method creates a new resource or replaces a representation of the target resource with the request payload.

nmap -p 80 --script http-put --script-args http-put.url='/uploads/rootme.php',http-put.file='/tmp/rootme.php'
curl --upload-file webshell.php -v --url http://192.168.126.129/test/test.txt

###### Testing for Arbitrary HTTP Methods

> / / / To Do

###### Testing for HTTP Method Overriding

> / / / To Do

###### Testing for Cross-Site Tracing Potential

The **TRACE** or **TRACK** HTTP methods, intended for testing and debugging, instructs the web server to reflect the received message back to the client. This method, while apparently harmless, can be successfully leveraged in some scenarios to steal legitimate users’ credentials.

> / / / To Finish

#### Authentication

> / / / To Do

##### HTTP Authentication

> / / / To Do

###### Basic

- Those are usually in Base64
- There is no implementation of Account Lockout
- Plaintext authentication 
- ....

Appache usts .htaccess
IIS uses local acocunts

We can bruteforce it.
Some can be bypass by simply doing a POST

```bash
curl -X POST http://vulnerable.com/
```

###### Digest

> / / / To Finish

Update of "Basic". 
- Uses MD5
  &rarr; Haschat

There has been an updated version of digest (RFC 2617) which added:
- Quality Of Protection flag: Indicates what "quality of protection" the client has applied to the message. If present, its value MUST be one of the alternatives the server indicated it supports in the WWW-Authenticate header.
These value affect the computation of the request-digest. 
- Client Nonce flag:

However:
- Digest as no Account Lockout mechanism
- No logout option (until the browser is closed)
- ...

Still not secure for today's world

The main difference between **Basic** and **Digest** is that the passwiord is never sent over the wire.

If we get a valid session, we can crack it easily



###### IWA

Integrated Windows Authentication is a authentication method used between Microsoft Internet Information Services, Internet Explorer, and other Active Directory aware applications.

It is typically seen within Intranet websites.

To attack this authentication method, we need to take advantages of a compromised client machine (cc CVE-2019-1040 and CVE-2019-1019)

###### Formed Based

> / / / To Finish

This is the most common nowadays.
We can try SQLi

Another possibility is to try Side-Channel Attacks.
Using a "timing side-channel attack", we could get maybe get username.
Previous know examples are:
- **CVE-2003-0637**:Product uses a shorter timeout for a non-existent user than a valid user, which makes it easier for remote attackers to guess usernames and conduct brute force password guessing.
- **CVE-2004-1602**: FTP server responds in a different amount of time when a given username exists, which allows remote attackers to identify valid usernames by timing the server response.
*Note that it is the same idea as Time-based SQL Injection*

For this, we will use the OWASP Zap Fuzzer module which show the time the request took.

###### *If you don't know, now you know: [Side-Channel Attacks](https://en.wikipedia.org/wiki/Side-channel_attack)*

A **side-channel attack** is any attack based on information gained from the implementation of a **computer system (CPU, RAM,GPU,...)**, rather than weaknesses in the implemented algorithm itself (e.g. cryptanalysis and software bugs). Timing information, power consumption, electromagnetic leaks or even sound can provide an extra source of information, which can be exploited.

The rise of Web 2.0 applications and software-as-a-service has also significantly raised the possibility of side-channel attacks on the web.

Two of the most known are "cache side-channel attack" where 

##### SQLi

A SQL Injection (SQLi) attack exploit the injection of SQL commands into the SQL queries of a web application.

###### Some basics

> / / / To Finish

- Stacked queries: Allows you to stack multiple queries together within a statement.
  This should be disabled but
  Within most databases, it's turned off by default, but some DBA turn it off again because the application has not been designed to avoid the use of stacked queries 
  If it's turned of you can still you the UNION statement

###### In-Band SQL injections

*In-band SQL injections** leverage the same channel used to inject the SQL code (i.e. the pages generated by the web application).

During and in-band attack the penetration tester finds a way to ask the the web application for the desired information.

try the following payloads:
- Username **'**: SELECT Username FROM Account WHERE Username
  -> 
- **"**:
- **';#**: Close the string > Close the SQL statement and comment the rest of it
- **';--**:

- User **\'\/\*** **\*/'** Name:
- User **'  '** Name: 

As you can see, **--** and **#** can be really be helpfull as they don't need to be delimited such as **\'\/\*** **\*/'** 

- **'*'**:
  -> Mean
- **'^'**:
  -> Mean regular expression ?
- **'&'**:

2) Leveraging UNION and NULL 

- UNION: Column types needs to be compatible 
- NULL: Matches any types of data 
  -> SELECT ..... **' UNION SELECT NULL, NULL, NULL, ...**

> / / / To Finish

3) Fingerprinting

|MySQL|MSSQL|Oracle|
|-|-|-|
|SELECT @@version|SELECT @@version|- - - |
|dbname()


SHOW TABLES


###### Error-Based SQL injectionS

> / / / To Finish

During an **Error-Based SQL injection** attack, the penetration tester tries to force the DMBS to output an **error message** and then uses that information to perform data exfiltration.
To exploit an error-based injection, we need to use advanced DBMS features.

unrecognized token:SQLite

###### Blind SQL injection

A web application vulnerable to **blind SQL injection** does not reflect the results of the injection on the output. In this case the penetration tester must find an **inference** method to exploit the vulnerability.

1) Content-based

Content-based SQL Injection or boolean-based SQL Injection is an inferential SQL Injection technique that relies on sending an SQL query to the database which forces the application to return a different result depending on whether the query returns a TRUE or FALSE result.

You may need to use the following parameter in SQLmap
--string

Here below is an example of secret enumeration

```sql
'AND CASE WHEN(
  (SELECT secret FROM users LIMIT 0,1) LIKE 'a%') THEN 1
  ELSE 0 END AND'
```

2) Time-based

This type of blind SQL injection relies on the database pausing for a specified amount of time, then returning the results, indicating successful SQL query executing. 

|MySQL|MSSQL|Oracle|PosgreSQL|
|-|-|-|-|
|SLEEP()|WAITFOR DELAY|BEGIN<br>DBMS_LOCK.SLEEP()|pg_sleep()|
|BENCHMARK()|WAITFOR TIME|UTL_HTTP.REQUEST()|-|
|-|-|UTL_INADDR.get_host_address()|-|
|-|-|UTL_INADDR.get_host_name()|-|

Some notes, if you don't have a lot of SQL skills

- A UNION statement implies DISTINCT by default. You can prevent that by using the ALL operator.

https://websec.ca/kb/sql_injection

##### Tools

1) Slqmap 

> / / / To Finish

- **-u**:
- **-r**:
  &rarr;
- **--crawl**:
- **--forms**:
- **--dbms**: Specify the database behind 
- **--referer**:  Bypass technique

2) BBQSQL

> / / / To Finish

[BBQSQL](https://github.com/CiscoCXSecurity/bbqsql) is a blind SQL injection framework written in Python. It is extremely useful when attacking tricky SQL injection vulnerabilities.

BBSQL can perform two types of Blind SQL Injection:
- Binary search (Default): It works by splitting the expected character.
  - If it return **TRUE**, 
- Frequency search:

1) w3af

> / / / To Finish

w3af is an open source web application security scanner which helps developers and penetration testers identify and exploit vulnerabilities in their web applications.

##### HTML Injection

> / / / To Finish

<script></script>
SVG

If Same-Origin Policy is enable, it's not a XSS

##### Cross-Site Scripting (XSS)

> / / / To Finish

Any user-controllable input could be vulnerable to an XSS.
Some entry points are:
- POST parameters
- URL query parameters
- HTTP Headers
  - User-Agent
  - Referer
  - Cookies

###### Type 2 - Reflected XSS 

Reflected attacks are those where the injected script is reflected off the web server, such as in an error message, search result, or any other response that includes some or all of the input sent to the server as part of the request. 

Reflected attacks are delivered to victims via **another route**, such as in an e-mail message, or on some other website.

When a user is tricked into clicking on a malicious link, submitting a specially crafted form, or even just browsing to a malicious site, the injected code travels to the vulnerable web site, which reflects the attack back to the user’s browser.

###### Type 1 - Stored XSS

Stored attacks are those where the injected script is permanently stored on the target servers, such as in a database, in a message forum, visitor log, comment field, etc. 

The victim then retrieves the malicious script from the server when it requests the stored information. 

###### Type 0 - DOM-Based XSS

> / / / To Finish

fuzzdb/attack-payloads/xss
JBroFuzz
XSSer

XXXsniper
XSSer
XSScrapy
BeEF

##### XML External Entity (XXE)

> / / / To Finish

Attackers can exploit vulnerable XML processors if they can upload XML or include hostile content in an XML document.

XXE are a type of Service-Side Request Forgery. The payload is run at the server side.  
For instance, if the server is running PHP, it will be difficult to see the function that is parsing the given XML document.


- SYSTEM "file:///
- SYSTEM "http://
- SYSTEM "expect://id" : 

##### Fuzzing

Fuzzing is a technique where we throughpout various types of security testing. 
The result of a fuzzing attacks depends on the:
- The payloads that have been sent
  &rarr; We will use multiple list based on what we are fuzzing
- The result of those payloads
- How we will interpret the result
  &rarr; Usually we search for anomalies based on all requests or errors

For instance on "http://victim.com/index.php?id=" we could try 
- A dictionnary attack to try LFI
  &rarr;Fuzzing/LFI/LFI-Jhaddix.txt
- A dictionnary attack to try SQLi
  &rarr;Fuzzing/SQLi/Generic-SQLi.txt
- A range of integer from 0 to 1000
- ...


The purpose of fuzzing relies on the assumption that there are bugs within every program, which are waiting to be discovered. Therefore, a systematic approach should find them sooner or later.


###### Wfuzz

Wfuzz can be used to look for hidden content, such as files and directories, within a web server, allowing to find further attack vectors.

- Passing cookies: -b cookie=value1 -b cookie2=value2
- Adding headers: -H "myheader: headervalue" -H "myheader2: headervalue2"
- Filter options:

Advanced tricks
```bash
wfuzz -z range --zD 0-1 -u http://target/script.php?id=FUZZ
wfuzz -p 127.0.0.1:<BURP_PORT>:HTTP # Add that, if you want to see the requests through a proxy like Burp 
```

###### Fuff

[Fuff](https://github.com/ffuf/ffuf) is a fast web fuzzer written in Go.

- Filter options:
  - **-fc**:Filter HTTP status codes from response. Comma separated list of codes and ranges
  - **-fl**:Filter by amount of lines in response. Comma separated list of line counts and ranges
  - **-fr**:Filter regexp
  - **-fs**:Filter HTTP response size. Comma separated list of sizes and rangesfw:Filter by amount of words in response. Comma separated list of word counts and ranges

###### GET parameter fuzzing

```bash
ffuf -w /path/to/paramnames.txt -u https://target/script.php?FUZZ=test_value
```

###### POST data fuzzing

```bash
ffuf -w /path/to/postdata.txt -X POST -d "username=admin\&password=FUZZ" -u https://target/login.php
wfuzz -z file,wordlist/others/common_pass.txt -d "username=FUZZ&pass=FUZZ" https://target/login.php
```

###### Cookie fuzzing

```bash
wfuzz -z z,path/to/wordlist.txt -b cookie=FUZZ http://target/
```